from typing import Dict, List
from poker_bot.agents.strategy_interface import StrategyInterface
import random


class ExploiterAgent(StrategyInterface):
    """
    Agent B: Exploiter - "The Shark"

    Purpose: Maximum exploitation of weak opponents.

    Strategy:
    - Aggressive value betting (extract maximum chips)
    - Frequent bluffing vs tight players
    - Blind stealing and position abuse
    - Relentless c-betting vs folders
    - Never bluff-catching vs passive players
    - Fast tempo to pressure MCTS bots
    - Weird bet sizes to break abstractions

    When to use:
    - vs Weak/Random opponents (maximum profit)
    - vs Rule-based opponents (exploit patterns)
    - vs MCTS (exploit abstraction gaps)
    - vs Hand-strength-only bots (bluff relentlessly)

    Expected performance:
    - vs Random: +40% win rate
    - vs Rule-based: +35% win rate
    - vs Hand-strength only: +45% win rate
    - vs GTO: -10% to -15% win rate (exploitable!)
    - High risk, high reward
    """

    def __init__(self):
        super().__init__()
        self.name = "Exploiter_Agent"
        self.description = "Aggressive exploiter - maximum profit vs weak opponents"

        # Aggressive parameters
        self.base_aggression = 2.0  # Very aggressive
        self.bluff_frequency = 0.35  # 35% bluff rate (high)
        self.value_bet_thin = True  # Bet marginal hands for value
        self.steal_frequency = 0.60  # 60% blind steal attempts

    def decide(self,
               hand_cards: List[str],
               community_cards: List[str],
               hand_strength: Dict,
               phase: str,
               pot: int,
               to_call: int,
               our_chips: int,
               position: str,
               num_players: int,
               opponent_profiles: List[Dict],
               current_bet: int) -> Dict:
        """Exploitative decision logic."""

        strength = hand_strength.get("strength", 0.0)
        hand_type = hand_strength.get("hand_type", "unknown")
        draw_potential = hand_strength.get("draw_potential", 0.0)

        # Analyze opponent tendencies
        avg_vpip, avg_aggression, avg_fold_to_cbet = self._analyze_opponents(opponent_profiles)

        # Adjust aggression based on opponents
        adjusted_aggression = self._calculate_adjusted_aggression(
            avg_vpip, avg_aggression, avg_fold_to_cbet
        )

        # Phase-specific strategy
        if phase == "PREFLOP":
            return self._decide_preflop(
                strength, pot, to_call, our_chips, position, num_players,
                avg_vpip, avg_fold_to_cbet, adjusted_aggression
            )
        else:
            return self._decide_postflop(
                strength, hand_type, draw_potential, pot, to_call,
                our_chips, position, num_players, phase,
                avg_vpip, avg_aggression, avg_fold_to_cbet, adjusted_aggression
            )

    def _decide_preflop(self, strength: float, pot: int, to_call: int,
                        our_chips: int, position: str, num_players: int,
                        avg_vpip: float, avg_fold_to_cbet: float,
                        adjusted_aggression: float) -> Dict:
        """Exploitative preflop strategy."""

        # Premium hands (AA-QQ, AK)
        if strength >= 0.90:
            if to_call == 0:
                # Large raise to build pot with premium hands
                raise_amount = pot * (1.0 + adjusted_aggression * 0.3)
                return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
            else:
                # Always re-raise premium hands aggressively
                raise_amount = to_call * (3 + adjusted_aggression)
                return {"action": "raise", "amount": min(int(raise_amount), our_chips)}

        # Strong hands (JJ-TT, AQ, AJs)
        elif strength >= 0.75:
            if to_call == 0:
                # Aggressive open raise
                raise_amount = pot * (0.8 + adjusted_aggression * 0.2)
                return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
            elif to_call < our_chips * 0.20:
                # Call or raise based on position
                if position in ["late", "middle"]:
                    raise_amount = to_call * 2.5
                    return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
                else:
                    return {"action": "call"}
            else:
                return {"action": "fold"}

        # Medium hands (99-77, suited connectors, broadway)
        elif strength >= 0.55:
            if to_call == 0:
                # Aggressive open raise from any position
                raise_amount = pot * (0.7 + adjusted_aggression * 0.2)
                return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
            elif to_call < pot * 0.4:
                # Call moderate bets
                return {"action": "call"}
            else:
                return {"action": "fold"}

        # Speculative hands (small pairs, suited cards)
        elif strength >= 0.40:
            if to_call == 0:
                # Steal attempt (very aggressive vs tight opponents)
                if avg_fold_to_cbet > 0.6 or position == "late":
                    raise_amount = pot * (0.6 + adjusted_aggression * 0.3)
                    return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
                else:
                    return {"action": "call"}
            elif to_call < pot * 0.25 and num_players >= 3:
                # Call with implied odds
                return {"action": "call"}
            else:
                return {"action": "fold"}

        # Weak hands (but we bluff a lot)
        else:
            if to_call == 0:
                # High frequency blind stealing
                if position in ["late", "middle"] and self._should_steal(avg_fold_to_cbet):
                    raise_amount = pot * (0.7 + random.uniform(0, 0.4))  # Weird sizing
                    return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
                else:
                    return {"action": "call"}
            else:
                return {"action": "fold"}

    def _decide_postflop(self, strength: float, hand_type: str,
                         draw_potential: float, pot: int, to_call: int,
                         our_chips: int, position: str, num_players: int,
                         phase: str, avg_vpip: float, avg_aggression: float,
                         avg_fold_to_cbet: float, adjusted_aggression: float) -> Dict:
        """Exploitative postflop strategy."""

        effective_strength = strength + draw_potential * 0.7

        # Very strong hands (two pair or better)
        if strength >= 0.75:
            if to_call == 0:
                # Maximum value extraction
                bet_size = self._calculate_exploit_bet_size(
                    pot, strength, num_players, avg_vpip, "value"
                )
                return {"action": "raise", "amount": min(int(bet_size), our_chips)}
            else:
                # Always raise for value vs passive players
                if avg_aggression < 1.5:
                    raise_amount = to_call * 2.5 + pot * 0.6
                    return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
                else:
                    # Call vs aggressive players (trap)
                    return {"action": "call"}

        # Strong hands (top pair good kicker, overpair)
        elif strength >= 0.55:
            if to_call == 0:
                # Aggressive value betting (thin value)
                bet_size = pot * (0.7 + adjusted_aggression * 0.2)
                return {"action": "raise", "amount": min(int(bet_size), our_chips)}
            elif to_call < pot * 0.8:
                # Call or raise based on opponent type
                if avg_vpip > 0.4:  # Loose opponent
                    # Raise for value vs loose players
                    raise_amount = to_call * 2 + pot * 0.3
                    return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
                else:
                    return {"action": "call"}
            else:
                # Fold to huge bets
                return {"action": "fold"}

        # Medium hands (middle pair, weak top pair)
        elif strength >= 0.40:
            if to_call == 0:
                # Bet for thin value vs loose players
                if avg_vpip > 0.35 or num_players <= 2:
                    bet_size = pot * (0.5 + adjusted_aggression * 0.2)
                    return {"action": "raise", "amount": min(int(bet_size), our_chips)}
                else:
                    return {"action": "call"}
            elif to_call < pot * 0.5 and avg_vpip > 0.4:
                # Call down lighter vs loose players
                return {"action": "call"}
            else:
                return {"action": "fold"}

        # Draws and weak hands
        elif effective_strength >= 0.30:
            if draw_potential >= 0.25:  # Strong draw
                if to_call == 0:
                    # Aggressive semi-bluffing
                    bet_size = pot * (0.6 + adjusted_aggression * 0.3)
                    return {"action": "raise", "amount": min(int(bet_size), our_chips)}
                elif to_call < pot * 0.6:
                    # Call with draws
                    return {"action": "call"}
                else:
                    return {"action": "fold"}
            else:
                # Weak hand
                if to_call == 0:
                    return {"action": "call"}
                else:
                    return {"action": "fold"}

        # Air (pure bluffs)
        else:
            if to_call == 0:
                # High frequency bluffing vs tight opponents
                if self._should_bluff(avg_fold_to_cbet, position, num_players):
                    # Weird bet sizes to break MCTS abstractions
                    bet_size = pot * (0.55 + random.uniform(0, 0.5))
                    return {"action": "raise", "amount": min(int(bet_size), our_chips)}
                else:
                    return {"action": "call"}
            else:
                # Occasionally bluff-raise vs tight players
                if avg_fold_to_cbet > 0.65 and to_call < pot and random.random() < 0.15:
                    raise_amount = to_call * 2.5 + pot * 0.4
                    return {"action": "raise", "amount": min(int(raise_amount), our_chips)}
                else:
                    return {"action": "fold"}

    def _analyze_opponents(self, opponent_profiles: List[Dict]) -> tuple:
        """Analyze opponent tendencies."""
        if not opponent_profiles:
            return 0.25, 1.0, 0.5  # Default assumptions

        total_vpip = 0
        total_aggression = 0
        total_fold_to_cbet = 0
        count = len(opponent_profiles)

        for profile in opponent_profiles:
            total_vpip += profile.get("vpip", 0.25)
            total_aggression += profile.get("aggression_factor", 1.0)
            total_fold_to_cbet += profile.get("fold_to_cbet", 0.5)

        return (
            total_vpip / count,
            total_aggression / count,
            total_fold_to_cbet / count
        )

    def _calculate_adjusted_aggression(self, avg_vpip: float,
                                        avg_aggression: float,
                                        avg_fold_to_cbet: float) -> float:
        """Calculate how aggressive we should be based on opponents."""

        # More aggressive vs tight opponents
        vpip_adjustment = (0.25 - avg_vpip) * 2.0

        # More aggressive vs passive opponents
        aggression_adjustment = (1.5 - avg_aggression) * 0.5

        # More aggressive vs opponents who fold a lot
        fold_adjustment = (avg_fold_to_cbet - 0.5) * 1.5

        adjusted = self.base_aggression + vpip_adjustment + aggression_adjustment + fold_adjustment

        # Clamp between 1.0 and 3.0
        return max(1.0, min(adjusted, 3.0))

    def _calculate_exploit_bet_size(self, pot: int, strength: float,
                                     num_players: int, avg_vpip: float,
                                     bet_type: str) -> float:
        """Calculate exploitative bet size."""

        if bet_type == "value":
            # Larger bets vs loose players (they call more)
            vpip_multiplier = 1.0 + (avg_vpip - 0.25) * 1.5

            # Base bet: 70-90% pot for value
            base_bet = pot * (0.7 + strength * 0.2)

            return base_bet * vpip_multiplier
        else:  # bluff
            # Weird sizing to break abstractions
            return pot * (0.5 + random.uniform(0, 0.6))

    def _should_steal(self, avg_fold_to_cbet: float) -> bool:
        """Should we attempt a blind steal?"""
        steal_chance = self.steal_frequency * (1 + (avg_fold_to_cbet - 0.5))
        return random.random() < steal_chance

    def _should_bluff(self, avg_fold_to_cbet: float, position: str,
                      num_players: int) -> bool:
        """Should we bluff?"""

        # Base bluff frequency
        bluff_chance = self.bluff_frequency

        # Increase vs tight opponents
        bluff_chance *= (1 + (avg_fold_to_cbet - 0.5) * 2)

        # Increase in late position
        if position == "late":
            bluff_chance *= 1.4
        elif position == "middle":
            bluff_chance *= 1.2

        # Decrease multiway
        if num_players > 2:
            bluff_chance *= 0.6

        return random.random() < min(bluff_chance, 0.65)  # Cap at 65%
